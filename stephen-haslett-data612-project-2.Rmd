---
title: "Data 612 Project 2 | Content-Based and Collaborative Filtering"
author: "Stephen Haslett"
date: "6/13/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra)
library(recommenderlab)
library(ggplot2)
```

## Assignment Instructions
The goal of this assignment is for you to try out different ways of implementing and configuring a recommender, and to evaluate your different approaches.
For assignment 2, start with an existing dataset of user-item ratings, such as our toy books dataset, MovieLens, Jester, or another dataset of your choosing.
Implement at least two of these recommendation algorithms:

- Content-Based Filtering
- User-User Collaborative Filtering
- Item-Item Collaborative Filtering

You should evaluate and compare different approaches, using different algorithms, normalization techniques, similarity methods, neighborhood sizes, etc.
You don’t need to be exhaustive—these are just some suggested possibilities.

You may use the course text’s recommenderlab or any other library that you want. Please provide at least one graph, and a textual summary of your findings and recommendations.

## Introduction
For this assignment, I used the MovieLense dataset that ships with the recommenderlab package to implement both user and item based collaborative filtering.

### Load the MovieLense Dataset
Each row of the MovieLense dataset corresponds to a user, each column corresponds to a movie, and each value is a rating. The dataset
contains 943 users, and 1664 movies.
```{r, warning=FALSE, message=FALSE}
set.seed(150)
data(MovieLense)
show(MovieLense)
```

### Data Exploration
Before implementing the recommender systems, I wanted to explore the data to get an idea of the distribution of ratings,
and to identify any inconsistencies in the data.

#### Ratings Exploration
Ratings are integer values ranging from 0 to 5. A zero value rating represents a missing value. As you can see from the below table,
there are a lot of missing values so in the interest of keeping our data accurate, we can remove these.
```{r, warning=FALSE, message=FALSE}
ratings_vector <- as.vector(MovieLense@data)
ratings_table <- table(ratings_vector)
ratings_table
```

#### Remove empty rating values.
```{r, warning=FALSE, message=FALSE}
ratings_vector <- ratings_vector[ratings_vector != 0]
ratings_table <- table(ratings_vector)
ratings_table
```


#### Ratings Distribution.
Now that we have removed the missing values, we can take a look at the distribution of ratings. As you can see from the below
histrogram, the most common movie ratings given by users are 3, 4, and 5, with 4 being the most frequent rating.

```{r, warning=FALSE, message=FALSE}
ratings_vector <- factor(ratings_vector)
qplot(ratings_vector) + ggtitle('Distribution of Ratings') +
  xlab('Rating') +
  ylab('Count') +
  geom_bar(fill = 'red')
```


#### Most Viewed Movies
The next thing I wanted to explore was which movies received the most views. The below histogram displays
the 10 most viewed movies. As we can see from the histogram, Star Wars received the most views.

```{r, warning=FALSE, message=FALSE}
views_per_movie <- colCounts(MovieLense)
views_table <- data.frame(
  movie = names(views_per_movie),
  views = views_per_movie
)

views_table <- views_table[order(views_table$views, decreasing = TRUE), ]
ggplot(views_table[1:10, ], aes(reorder(movie, - views), y = views)) +
geom_bar(stat = 'identity', fill = 'red') +
theme(axis.text.x = element_text(angle = 50, hjust = 1)) +
  ggtitle('10 Most Viewed Movies') +
  xlab('Movie') +
  ylab('Number of Views')
```



## Data Preperation
Data preperation will involve prunning the data to ensure the accuracy of our recommendations, and splitting the data
into test and training datasets.

### Prune The Data
Increase the accuracy of recommendations by selecting only users who have rated at least 50 movies, and
selecting movies that have been watched at least 100 times.

```{r, warning=FALSE, message=FALSE}
movie_ratings <- MovieLense[rowCounts(MovieLense) > 50, colCounts(MovieLense) > 100]
```

### Average Rating Per User Distribution
A quick look at the average rating per user distribution shows us that there is a lot of variation
across the ratings data.
```{r, warning=FALSE, message=FALSE}
average_ratings_per_user <- rowMeans(movie_ratings)
qplot(average_ratings_per_user) + ggtitle('Average Rating Per User Distribution') +
  xlab('Average Rating Per User') +
  ylab('Count')
```


#### Create the training and test data
```{r, warning=FALSE, message=FALSE}
train <- sample(x = c(TRUE, FALSE), size = nrow(movie_ratings), replace =TRUE, prob = c(0.8, 0.2))
training_data <- movie_ratings[train, ]
test_data <- movie_ratings[!train, ]
```


## Item Based Collaborative Filtering

#### Build the item based model
```{r, warning=FALSE, message=FALSE}
item_item_model <- Recommender(data = training_data, method = 'IBCF')
item_item_model
```


### Apply the model to the test data.
```{r, warning=FALSE, message=FALSE}
predicted <- predict(object = item_item_model, newdata = test_data, n = 6)
recommendation_matrix <- sapply(predicted@items, function(x) {
                           colnames(movie_ratings)[x]
                         })

# First 4 user recommendations.
recommendation_matrix[, 1:4]
```


### Most popular movies
```{r, warning=FALSE, message=FALSE}
items_count <- factor(table(recommendation_matrix))
qplot(items_count) + ggtitle('Distribution of IBCF items')
```

```{r, warning=FALSE, message=FALSE}
items_count_sorted <- sort(items_count, decreasing = TRUE)
top_items <- head(items_count_sorted, n = 10)
top_items_table <- data.frame(top_items)
colnames(top_items_table) <- c('Rating')
top_items_table
```


## User Based Collaborative Filtering

#### Build the user based model
```{r, warning=FALSE, message=FALSE}
user_user_model <- Recommender(data = training_data, method = 'UBCF')
user_user_model
```

### Apply the model to the test data.
```{r, warning=FALSE, message=FALSE}
predicted <- predict(object = user_user_model, newdata = test_data, n = 6)
recommendation_matrix <- sapply(predicted@items, function(x) {
                           colnames(movie_ratings)[x]
                         })

# First 4 user recommendations.
recommendation_matrix[, 1:4]
```

### Most popular movies
```{r, warning=FALSE, message=FALSE}
items_count <- factor(table(recommendation_matrix))
qplot(items_count) + ggtitle('Distribution of UBCF items')
```

```{r, warning=FALSE, message=FALSE}
items_count_sorted <- sort(items_count, decreasing = TRUE)
top_items <- head(items_count_sorted, n = 10)
top_items_table <- data.frame(top_items)
colnames(top_items_table) <- c('Rating')
top_items_table
```
